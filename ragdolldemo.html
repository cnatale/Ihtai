
<!DOCTYPE html>
<html>
<head>
    <title>Ragdoll demo - p2.js physics engine</title>
    <script src="js/external/p2/p2.js"></script>
    <script src="js/external/p2/p2.renderer.js"></script>
    <style>
    html,body {
        margin:0;
        padding:0;
        width:100%;
        height:100%;
        overflow: hidden;
    }
    </style>

    <meta name="description" content="A rag doll learning to stand upright using IHTAI.">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>
    <!-- the slider to control amount of daydreaming (between 0 and 1) -->
    <label style="z-index:9999;position:absolute;">Daydreaming</label>
    <input id="daydreamRange" type=range id=weight min=0 value=1 max=1 step=.05
    style="z-index:9999;position:absolute;left:100px">

    <script src="js/ihtai/ihtai.js"></script>
    <script src="js/ihtai/utils.js"></script>
    <script>
        var daydreamRange=document.getElementById('daydreamRange');
        var daydreamPct=1;
        //update the pct of time agent daydreams (1=100pct of time)
        daydreamRange.addEventListener('change', function(e){
            daydreamPct=Number(e.currentTarget.value);
        });

        function normalizeAngle(angle){
            angle = angle % (2*Math.PI);
            if(angle < 0){
                angle += (2*Math.PI);
            }
            return angle;
        }
        var world;
        var pelvis, lowerLeftLeg, lowerRightLeg, lowerLeftArm, lowerRightArm;        

        var shouldersDistance = 0.5,
            upperArmLength = 0.4,
            lowerArmLength = 0.4,
            upperArmSize = 0.2,
            lowerArmSize = 0.2,
            neckLength = 0.1,
            headRadius = 0.25,
            upperBodyLength = 0.6,
            pelvisLength = 0.4,
            upperLegLength = 0.5,
            upperLegSize = 0.2,
            lowerLegSize = 0.2,
            lowerLegLength = 0.5;

        // Create demo application
        var app = new p2.WebGLRenderer(function(){

            var OTHER =     Math.pow(2,1),
                BODYPARTS = Math.pow(2,2),
                GROUND =    Math.pow(2,3),
                OTHER =     Math.pow(2,4),
                WALLS =     Math.pow(2,5),
                bodyPartShapes = [];

            var headShape = new p2.Circle({ radius: headRadius }),
                upperArmShapeLeft = new p2.Box({ width: upperArmLength, height: upperArmSize }),
                upperArmShapeRight = new p2.Box({ width: upperArmLength, height: upperArmSize }),
                lowerArmShapeLeft = new p2.Box({ width: lowerArmLength, height: lowerArmSize }),
                lowerArmShapeRight = new p2.Box({ width: lowerArmLength, height: lowerArmSize }),
                upperBodyShape = new p2.Box({ width: shouldersDistance, height: upperBodyLength }),
                pelvisShape = new p2.Box({ width: shouldersDistance, height: pelvisLength }),
                upperLegShapeLeft = new p2.Box({ width: upperLegSize, height: upperLegLength }),
                upperLegShapeRight = new p2.Box({ width: upperLegSize, height: upperLegLength }),
                lowerLegShapeLeft = new p2.Box({ width: lowerLegSize, height: lowerLegLength }),
                lowerLegShapeRight = new p2.Box({ width: lowerLegSize, height: lowerLegLength });

            bodyPartShapes.push(
                headShape,
                upperArmShapeRight,
                upperArmShapeLeft,
                lowerArmShapeRight,
                lowerArmShapeLeft,
                upperBodyShape,
                pelvisShape,
                upperLegShapeRight,
                upperLegShapeLeft,
                lowerLegShapeRight,
                lowerLegShapeLeft
            );

            for(var i=0; i<bodyPartShapes.length; i++){
                var s = bodyPartShapes[i];
                s.collisionGroup = BODYPARTS;
                s.collisionMask = GROUND|OTHER|WALLS;
            }

            world = new p2.World({
                gravity : [0,-10]
            });

            this.setWorld(world);

            world.solver.iterations = 100;
            world.solver.tolerance = 0.002;

            // Lower legs
            lowerLeftLeg = new p2.Body({
                mass: 1,
                position: [-shouldersDistance/2,lowerLegLength / 2],
            });
            lowerRightLeg = new p2.Body({
                mass: 1,
                position: [shouldersDistance/2,lowerLegLength / 2],
            });
            lowerLeftLeg.addShape(lowerLegShapeLeft);
            lowerRightLeg.addShape(lowerLegShapeRight);
            world.addBody(lowerLeftLeg);
            world.addBody(lowerRightLeg);

            // Upper legs
            var upperLeftLeg = new p2.Body({
                mass: 1,
                position: [-shouldersDistance/2,lowerLeftLeg.position[1]+lowerLegLength/2+upperLegLength / 2],
            });
            var upperRightLeg = new p2.Body({
                mass: 1,
                position: [shouldersDistance/2,lowerRightLeg.position[1]+lowerLegLength/2+upperLegLength / 2],
            });
            upperLeftLeg.addShape(upperLegShapeLeft);
            upperRightLeg.addShape(upperLegShapeRight);
            world.addBody(upperLeftLeg);
            world.addBody(upperRightLeg);

            // Pelvis
            pelvis = new p2.Body({
                mass: 1,
                position: [0, upperLeftLeg.position[1]+upperLegLength/2+pelvisLength/2],
            });
            pelvis.addShape(pelvisShape);
            world.addBody(pelvis);

            // Upper body
            var upperBody = new p2.Body({
                mass: 1,
                position: [0,pelvis.position[1]+pelvisLength/2+upperBodyLength/2],
            });
            upperBody.addShape(upperBodyShape);
            world.addBody(upperBody);

            // Head
            var head = new p2.Body({
                mass: 1,
                position: [0,upperBody.position[1]+upperBodyLength/2+headRadius+neckLength],
            });
            head.addShape(headShape);
            world.addBody(head);

            // Upper arms
            var upperLeftArm = new p2.Body({
                mass: 1,
                position: [-shouldersDistance/2-upperArmLength/2, upperBody.position[1]+upperBodyLength/2],
            });
            var upperRightArm = new p2.Body({
                mass: 1,
                position: [shouldersDistance/2+upperArmLength/2, upperBody.position[1]+upperBodyLength/2],
            });
            upperLeftArm.addShape(upperArmShapeLeft);
            upperRightArm.addShape(upperArmShapeRight);
            world.addBody(upperLeftArm);
            world.addBody(upperRightArm);

            // lower arms
            lowerLeftArm = new p2.Body({
                mass: 1,
                position: [ upperLeftArm.position[0] - lowerArmLength/2 - upperArmLength/2,
                            upperLeftArm.position[1]],
            });
            lowerRightArm = new p2.Body({
                mass: 1,
                position: [ upperRightArm.position[0] + lowerArmLength/2 + upperArmLength/2,
                            upperRightArm.position[1]],
            });
            lowerLeftArm.addShape(lowerArmShapeLeft);
            lowerRightArm.addShape(lowerArmShapeRight);
            world.addBody(lowerLeftArm);
            world.addBody(lowerRightArm);


            // Neck joint
            var neckJoint = new p2.RevoluteConstraint(head, upperBody, {
                localPivotA: [0,-headRadius-neckLength/2],
                localPivotB: [0,upperBodyLength/2],
            });
            neckJoint.setLimits(-Math.PI / 8, Math.PI / 8);
            world.addConstraint(neckJoint);

            // Knee joints
            var leftKneeJoint = new p2.RevoluteConstraint(lowerLeftLeg, upperLeftLeg, {
                localPivotA: [0, lowerLegLength/2],
                localPivotB: [0,-upperLegLength/2],
            });
            var rightKneeJoint= new p2.RevoluteConstraint(lowerRightLeg, upperRightLeg, {
                localPivotA: [0, lowerLegLength/2],
                localPivotB:[0,-upperLegLength/2],
            });
            leftKneeJoint.setLimits(-Math.PI / 8, Math.PI / 8);
            rightKneeJoint.setLimits(-Math.PI / 8, Math.PI / 8);
            world.addConstraint(leftKneeJoint);
            world.addConstraint(rightKneeJoint);

            // Hip joints
            var leftHipJoint = new p2.RevoluteConstraint(upperLeftLeg, pelvis, {
                localPivotA: [0, upperLegLength/2],
                localPivotB: [-shouldersDistance/2,-pelvisLength/2],
            });
            var rightHipJoint = new p2.RevoluteConstraint(upperRightLeg, pelvis, {
                localPivotA: [0, upperLegLength/2],
                localPivotB: [shouldersDistance/2,-pelvisLength/2],
            });
            leftHipJoint.setLimits(-Math.PI / 8, Math.PI / 8);
            rightHipJoint.setLimits(-Math.PI / 8, Math.PI / 8);
            world.addConstraint(leftHipJoint);
            world.addConstraint(rightHipJoint);

            // Spine
            var spineJoint = new p2.RevoluteConstraint(pelvis, upperBody, {
                localPivotA: [0,pelvisLength/2],
                localPivotB: [0,-upperBodyLength/2],
            });
            spineJoint.setLimits(-Math.PI / 8, Math.PI / 8);
            world.addConstraint(spineJoint);

            // Shoulders
            var leftShoulder = new p2.RevoluteConstraint(upperBody, upperLeftArm, {
                localPivotA:[-shouldersDistance/2, upperBodyLength/2],
                localPivotB:[upperArmLength/2,0],
            });
            var rightShoulder= new p2.RevoluteConstraint(upperBody, upperRightArm, {
                localPivotA:[shouldersDistance/2,  upperBodyLength/2],
                localPivotB:[-upperArmLength/2,0],
            });
            leftShoulder.setLimits(-Math.PI / 3, Math.PI / 3);
            rightShoulder.setLimits(-Math.PI / 3, Math.PI / 3);
            world.addConstraint(leftShoulder);
            world.addConstraint(rightShoulder);

            // Elbow joint
            var leftElbowJoint = new p2.RevoluteConstraint(lowerLeftArm, upperLeftArm, {
                localPivotA: [lowerArmLength/2, 0],
                localPivotB: [-upperArmLength/2,0],
            });
            var rightElbowJoint= new p2.RevoluteConstraint(lowerRightArm, upperRightArm, {
                localPivotA:[-lowerArmLength/2,0],
                localPivotB:[upperArmLength/2,0],
            });
            leftElbowJoint.setLimits(-Math.PI / 8, Math.PI / 8);
            rightElbowJoint.setLimits(-Math.PI / 8, Math.PI / 8);
            world.addConstraint(leftElbowJoint);
            world.addConstraint(rightElbowJoint);

            // Create ground
            var planeShape = new p2.Plane();
            var plane = new p2.Body({
                position:[0,-1],
            });
            plane.addShape(planeShape);
            //plane.addShape(leftWallShape);
            planeShape.collisionGroup = GROUND;
            planeShape.collisionMask =  BODYPARTS|OTHER|WALLS;
            world.addBody(plane);

            //create walls
            var leftWallShape = new p2.Plane();
            var leftWall = new p2.Body({
                position:[-8,0],
                angle:[3*Math.PI/2]
            });
            /*var leftWallShape = new p2.Box({ width: 10, height: 15 }),            
            leftWall = new p2.Body({
                mass: 100000,
                position: [-10, 5],
            });*/
            leftWall.addShape(leftWallShape);
            leftWall.collisionGroup = GROUND;
            leftWall.collisionMask = BODYPARTS|OTHER;
            world.addBody(leftWall);

            leftWallShape.collisionGroup = WALLS;
            leftWallShape.collisionMask =  BODYPARTS|OTHER|GROUND;

            var rightWallShape = new p2.Plane();
            var rightWall = new p2.Body({
                position:[8,0],
                angle:[Math.PI/2]
            });

            /*var rightWallShape = new p2.Box({ width: 10, height: 15 }),            
            rightWall = new p2.Body({
                mass: 100000,
                position: [10, 5],
            });*/
            rightWall.addShape(rightWallShape);
            rightWall.collisionGroup = GROUND;
            rightWall.collisionMask = BODYPARTS|OTHER;
            world.addBody(rightWall);

            rightWallShape.collisionGroup = WALLS;
            rightWallShape.collisionMask =  BODYPARTS|OTHER|GROUND;       

            var topWallShape = new p2.Plane();
            var topWall = new p2.Body({
                position:[0,10],
                angle:[Math.PI]
            });
            /*var topWallShape = new p2.Box({ width: 40, height: 10 }),            
            topWall = new p2.Body({
                mass: 100000,
                position: [0, 20],
            });*/
            topWall.addShape(topWallShape);
            topWall.collisionGroup = GROUND;
            topWall.collisionMask = BODYPARTS|OTHER;
            world.addBody(topWall);

            topWallShape.collisionGroup = OTHER;
            topWallShape.collisionMask =  BODYPARTS|WALLS|GROUND;                  
        });

        //initialize Ihtai
        var uprightDrive={
            init:function(){
                this.uprightVal=0;
                this.prevUprightVal=0;
            },
            cycle:function(stm,dt){
                this.prevUprightVal=this.uprightVal;

                //stm[0]  is the upright angle, normalized
                //check if torso is reasonably upright
                if(stm[0] >= 0 && stm[0] <= Math.PI/8 || stm[0] >= (15*Math.PI)/8 && stm[0] <= 2*Math.PI ){
                    this.uprightVal<=0?this.uprightVal=0:this.uprightVal-=1;
                    //this.uprightVal=0;
                    console.log('UPRIGHT');
                }
                else{    
                    this.uprightVal>=30?this.uprightVal=30:this.uprightVal+=1;                    
                    //this.uprightVal=30;
                }

                //return this.isUpright?0:10;
                return this.uprightVal;
            },
            undo:function(){         
                this.uprightVal=this.prevUprightVal;
                return this.uprightVal;
            },
            targetval:0 //the goal value
        };
        var drives=[uprightDrive];
        var reflexes=[];
        var ihtai = new Ihtai({
            clusterCount:500,
            vectorDim:14,/*number of iostm values + drives*/
            memoryHeight:200,/*how many steps ahead can ihtai look for an optimal stm trail?*/
            drivesList:drives,
            reflexList:reflexes,
            acceptableRange:9999,/*acceptable range for optimal stm is in square dist*/
            /*backStimCt:0,*/
            distanceAlgo:"avg" /*avg or endState*/

        });

        function roundToTenth(num){
            num*=10
            num=num >> 0;
            num/=10;
            return num;
        }

        /*
        add touch [0 or 1] sensing for btm left arm, btm right arm, btm left leg, btm right leg.
        */
        var lowerLeftLegTouch=0, lowerRightLegTouch=0,lowerLeftArmTouch=0,lowerRightArmTouch=0;
        function onBeginContact(payload){
            switch(payload.bodyA.id){
                case lowerLeftLeg.id:
                    lowerLeftLegTouch=1;
                break;
                case lowerRightLeg.id:
                    lowerRightLegTouch=1;
                break;
                case lowerLeftArm.id:
                    lowerLeftArmTouch=1;
                break;
                case lowerRightArm.id:
                    lowerRightArmTouch=1;
                break;
            }
            switch(payload.bodyB.id){
                case lowerLeftLeg.id:
                    lowerLeftLegTouch=1;
                break;
                case lowerRightLeg.id:
                    lowerRightLegTouch=1;
                break;
                case lowerLeftArm.id:
                    lowerLeftArmTouch=1;
                break;
                case lowerRightArm.id:
                    lowerRightArmTouch=1;
                break;               
            }
            //debugger;
            //a=1;
        }        
        function onEndContact(payload){
            switch(payload.bodyA.id){
                case lowerLeftLeg.id:
                    lowerLeftLegTouch=0;
                break;
                case lowerRightLeg.id:
                    lowerRightLegTouch=0;
                break;
                case lowerLeftArm.id:
                    lowerLeftArmTouch=0;
                break;
                case lowerRightArm.id:
                    lowerRightArmTouch=0;
                break;
            }
            switch(payload.bodyB.id){
                case lowerLeftLeg.id:
                    lowerLeftLegTouch=0;
                break;
                case lowerRightLeg.id:
                    lowerRightLegTouch=0;
                break;
                case lowerLeftArm.id:
                    lowerLeftArmTouch=0;
                break;
                case lowerRightArm.id:
                    lowerRightArmTouch=0;
                break;               
            }
            //debugger;
            //a=1;
        }   

        world.on("beginContact", onBeginContact);
        world.on("endContact", onEndContact);


        var lowerLeftLegForce=0, lowerRightLegForce=0, lowerLeftArmForce=0, lowerRightArmForce=0;
        var firstCycle=true;
        var lastTime=new Date().getTime(), currentTime=new Date().getTime(), dt;
        //body parts under control of Ihtai: pelvis, lowerLeftLeg, lowerRightLeg, lowerLeftArm, lowerRightArm;
        function mainLoop(){
            currentTime= new Date().getTime();
            dt= currentTime-lastTime;

            var normalizedAngle=roundToTenth(normalizeAngle(pelvis.angle));
            var lllegAngle = roundToTenth(normalizeAngle(lowerLeftLeg.angle));
            var lrlegAngle = roundToTenth(normalizeAngle(lowerRightLeg.angle));
            var llarmAngle = roundToTenth(normalizeAngle(lowerLeftArm.angle));
            var lrarmAngle = roundToTenth(normalizeAngle(lowerRightArm.angle));
            //console.log(normalizedAngle);

            var inputStm=[normalizedAngle, lowerLeftLegForce, lowerRightLegForce, lowerLeftArmForce, lowerRightArmForce,
               lllegAngle, lrlegAngle, llarmAngle, lrarmAngle, lowerLeftLegTouch, lowerRightLegTouch, lowerLeftArmTouch, lowerRightArmTouch
            ];
            var res;

            if(Math.random() > daydreamPct || firstCycle){
                res=ihtai.cycle(inputStm, dt);
                firstCycle=false; //necessary b/c there are no clusters to daydream about before first cycle
            }
            else{
                res=ihtai.daydream(inputStm, dt, [1,2,3,4]);
            }

            //////// apply forces based on ihtai response ////////
            if(res.memorizerOutput[0] != null){
                console.log('memorizer');
                //handle movement conditions for each
                lowerLeftLegForce=res.memorizerOutput[0][1];
                lowerRightLegForce=res.memorizerOutput[0][2];
                lowerLeftArmForce=res.memorizerOutput[0][3];
                lowerRightArmForce=res.memorizerOutput[0][4];
            }
            else{
                console.log('reflex')
                //apply random movement signals to each muscle
                lowerLeftLegForce=IhtaiUtils.weightedRand({'-100':.33, '0':.33, '100':.33});
                lowerRightLegForce=IhtaiUtils.weightedRand({'-100':.33, '0':.33, '100':.33});
                lowerLeftArmForce=IhtaiUtils.weightedRand({'-100':.33, '0':.33, '100':.33});
                lowerRightArmForce=IhtaiUtils.weightedRand({'-100':.33, '0':.33, '100':.33});              
            }

            //apply forces on body parts
            //console.log('dt: '+dt)
            //adding a relative force based on dt breaks learning. investigate.
            lowerLeftLeg.applyForce([lowerLeftLegForce * 3/*(dt/1),0],[0,0]);
            lowerRightLeg.applyForce([lowerRightLegForce * 3/*(dt/1)*/,0],[0,0]);
            lowerLeftArm.applyForce([lowerLeftArmForce * 3/*(dt/1)*/,0],[0,0]);
            lowerRightArm.applyForce([lowerRightArmForce * 3/*(dt/1)*/,0],[0,0]);
            lastTime=currentTime;
        }
        window.setInterval(mainLoop,0);//for some reason setting this to anything other than zero is breaking code. character just collapses after switch to kd tree. not sure why.

    </script>
</body>
</html>
